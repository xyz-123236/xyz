Oracle 递归查询
在 Oracle 中是通过 start with connect by prior 语法来实现递归查询的。
按照 prior 关键字在子节点端还是父节点端，以及是否包含当前查询的节点，共分为四种情况。

prior 在子节点端（向下递归）
第一种情况： start with 子节点id = ' 查询节点 ' connect by prior 子节点id = 父节点id
select * from dept start with id='1001' connet by prior id=pid;
这里，按照条件 id='1001' 对当前节点以及它的子节点递归查询。查询结果包含自己及所有子节点。

第二种情况： start with 父节点id= ' 查询节点 ' connect by prior 子节点id = 父节点 id
select * from dept start with pid='1001' connect by prior id=pid;
这里，按照条件 pid='1001' 对当前节点的所有子节点递归查询。查询结果只包含它的所有子节点，不包含自己。

其实想一想也对，因为开始条件是以父节点为根节点，且向下递归，自然不包含当前节点。

prior 在父节点端（向上递归）
第三种情况： start with 子节点id= ' 查询节点 ' connect by prior 父节点id = 子节点id
select * from dept start with id='1001' connect by prior pid=id;
这里按照条件 id='1001' ，对当前节点及其父节点递归查询。查询结果包括自己及其所有父节点。

第四种情况： start with 父节点id= ' 查询节点 ' connect by prior 父节点id = 子节点id
select * from dept start with pid='1001' connect by prior pid=id;
这里按照条件 pid='1001'，对当前节点的第一代子节点以及它的父节点递归查询。查询结果包括自己的第一代子节点以及所有父节点。（包括自己）

其实这种情况也好理解，因为查询开始条件是以 父节点为根节点，且向上递归，自然需要把当前父节点的第一层子节点包括在内。

以上四种情况初看可能会让人迷惑，容易记混乱，其实不然。
我们只需要记住 prior 的位置在子节点端，就向下递归，在父节点端就向上递归。
开始条件若是子节点的话，自然包括它本身的节点。
开始条件若是父节点的话，则向下递归时，自然不包括当前节点。而向上递归，需要包括当前节点及其第一代子节点。